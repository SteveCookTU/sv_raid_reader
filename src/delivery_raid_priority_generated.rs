// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum DeliveryGroupIDOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeliveryGroupID<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeliveryGroupID<'a> {
    type Inner = DeliveryGroupID<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DeliveryGroupID<'a> {
    pub const VT_GROUPID_01: flatbuffers::VOffsetT = 4;
    pub const VT_GROUPID_02: flatbuffers::VOffsetT = 6;
    pub const VT_GROUPID_03: flatbuffers::VOffsetT = 8;
    pub const VT_GROUPID_04: flatbuffers::VOffsetT = 10;
    pub const VT_GROUPID_05: flatbuffers::VOffsetT = 12;
    pub const VT_GROUPID_06: flatbuffers::VOffsetT = 14;
    pub const VT_GROUPID_07: flatbuffers::VOffsetT = 16;
    pub const VT_GROUPID_08: flatbuffers::VOffsetT = 18;
    pub const VT_GROUPID_09: flatbuffers::VOffsetT = 20;
    pub const VT_GROUPID_10: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DeliveryGroupID { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DeliveryGroupIDArgs,
    ) -> flatbuffers::WIPOffset<DeliveryGroupID<'bldr>> {
        let mut builder = DeliveryGroupIDBuilder::new(_fbb);
        builder.add_groupID_10(args.groupID_10);
        builder.add_groupID_09(args.groupID_09);
        builder.add_groupID_08(args.groupID_08);
        builder.add_groupID_07(args.groupID_07);
        builder.add_groupID_06(args.groupID_06);
        builder.add_groupID_05(args.groupID_05);
        builder.add_groupID_04(args.groupID_04);
        builder.add_groupID_03(args.groupID_03);
        builder.add_groupID_02(args.groupID_02);
        builder.add_groupID_01(args.groupID_01);
        builder.finish()
    }

    #[inline]
    pub fn groupID_01(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_01, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_02(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_02, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_03(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_03, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_04(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_04, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_05(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_05, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_06(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_06, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_07(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_07, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_08(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_08, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_09(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_09, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn groupID_10(&self) -> i8 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i8>(DeliveryGroupID::VT_GROUPID_10, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for DeliveryGroupID<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i8>("groupID_01", Self::VT_GROUPID_01, false)?
            .visit_field::<i8>("groupID_02", Self::VT_GROUPID_02, false)?
            .visit_field::<i8>("groupID_03", Self::VT_GROUPID_03, false)?
            .visit_field::<i8>("groupID_04", Self::VT_GROUPID_04, false)?
            .visit_field::<i8>("groupID_05", Self::VT_GROUPID_05, false)?
            .visit_field::<i8>("groupID_06", Self::VT_GROUPID_06, false)?
            .visit_field::<i8>("groupID_07", Self::VT_GROUPID_07, false)?
            .visit_field::<i8>("groupID_08", Self::VT_GROUPID_08, false)?
            .visit_field::<i8>("groupID_09", Self::VT_GROUPID_09, false)?
            .visit_field::<i8>("groupID_10", Self::VT_GROUPID_10, false)?
            .finish();
        Ok(())
    }
}
pub struct DeliveryGroupIDArgs {
    pub groupID_01: i8,
    pub groupID_02: i8,
    pub groupID_03: i8,
    pub groupID_04: i8,
    pub groupID_05: i8,
    pub groupID_06: i8,
    pub groupID_07: i8,
    pub groupID_08: i8,
    pub groupID_09: i8,
    pub groupID_10: i8,
}
impl<'a> Default for DeliveryGroupIDArgs {
    #[inline]
    fn default() -> Self {
        DeliveryGroupIDArgs {
            groupID_01: 0,
            groupID_02: 0,
            groupID_03: 0,
            groupID_04: 0,
            groupID_05: 0,
            groupID_06: 0,
            groupID_07: 0,
            groupID_08: 0,
            groupID_09: 0,
            groupID_10: 0,
        }
    }
}

pub struct DeliveryGroupIDBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeliveryGroupIDBuilder<'a, 'b> {
    #[inline]
    pub fn add_groupID_01(&mut self, groupID_01: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_01, groupID_01, 0);
    }
    #[inline]
    pub fn add_groupID_02(&mut self, groupID_02: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_02, groupID_02, 0);
    }
    #[inline]
    pub fn add_groupID_03(&mut self, groupID_03: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_03, groupID_03, 0);
    }
    #[inline]
    pub fn add_groupID_04(&mut self, groupID_04: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_04, groupID_04, 0);
    }
    #[inline]
    pub fn add_groupID_05(&mut self, groupID_05: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_05, groupID_05, 0);
    }
    #[inline]
    pub fn add_groupID_06(&mut self, groupID_06: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_06, groupID_06, 0);
    }
    #[inline]
    pub fn add_groupID_07(&mut self, groupID_07: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_07, groupID_07, 0);
    }
    #[inline]
    pub fn add_groupID_08(&mut self, groupID_08: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_08, groupID_08, 0);
    }
    #[inline]
    pub fn add_groupID_09(&mut self, groupID_09: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_09, groupID_09, 0);
    }
    #[inline]
    pub fn add_groupID_10(&mut self, groupID_10: i8) {
        self.fbb_
            .push_slot::<i8>(DeliveryGroupID::VT_GROUPID_10, groupID_10, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeliveryGroupIDBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DeliveryGroupIDBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DeliveryGroupID<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DeliveryGroupID<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DeliveryGroupID");
        ds.field("groupID_01", &self.groupID_01());
        ds.field("groupID_02", &self.groupID_02());
        ds.field("groupID_03", &self.groupID_03());
        ds.field("groupID_04", &self.groupID_04());
        ds.field("groupID_05", &self.groupID_05());
        ds.field("groupID_06", &self.groupID_06());
        ds.field("groupID_07", &self.groupID_07());
        ds.field("groupID_08", &self.groupID_08());
        ds.field("groupID_09", &self.groupID_09());
        ds.field("groupID_10", &self.groupID_10());
        ds.finish()
    }
}
pub enum DeliveryRaidPriorityOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeliveryRaidPriority<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeliveryRaidPriority<'a> {
    type Inner = DeliveryRaidPriority<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DeliveryRaidPriority<'a> {
    pub const VT_VERSIONNO: flatbuffers::VOffsetT = 4;
    pub const VT_DELIVERYGROUPID: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DeliveryRaidPriority { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DeliveryRaidPriorityArgs<'args>,
    ) -> flatbuffers::WIPOffset<DeliveryRaidPriority<'bldr>> {
        let mut builder = DeliveryRaidPriorityBuilder::new(_fbb);
        if let Some(x) = args.deliveryGroupID {
            builder.add_deliveryGroupID(x);
        }
        builder.add_versionNo(args.versionNo);
        builder.finish()
    }

    #[inline]
    pub fn versionNo(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(DeliveryRaidPriority::VT_VERSIONNO, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn deliveryGroupID(&self) -> DeliveryGroupID<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DeliveryGroupID>>(
                    DeliveryRaidPriority::VT_DELIVERYGROUPID,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for DeliveryRaidPriority<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("versionNo", Self::VT_VERSIONNO, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<DeliveryGroupID>>(
                "deliveryGroupID",
                Self::VT_DELIVERYGROUPID,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DeliveryRaidPriorityArgs<'a> {
    pub versionNo: i32,
    pub deliveryGroupID: Option<flatbuffers::WIPOffset<DeliveryGroupID<'a>>>,
}
impl<'a> Default for DeliveryRaidPriorityArgs<'a> {
    #[inline]
    fn default() -> Self {
        DeliveryRaidPriorityArgs {
            versionNo: 0,
            deliveryGroupID: None,
        }
    }
}

pub struct DeliveryRaidPriorityBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeliveryRaidPriorityBuilder<'a, 'b> {
    #[inline]
    pub fn add_versionNo(&mut self, versionNo: i32) {
        self.fbb_
            .push_slot::<i32>(DeliveryRaidPriority::VT_VERSIONNO, versionNo, 0);
    }
    #[inline]
    pub fn add_deliveryGroupID(
        &mut self,
        deliveryGroupID: flatbuffers::WIPOffset<DeliveryGroupID<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DeliveryGroupID>>(
                DeliveryRaidPriority::VT_DELIVERYGROUPID,
                deliveryGroupID,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DeliveryRaidPriorityBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DeliveryRaidPriorityBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DeliveryRaidPriority<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DeliveryRaidPriority<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DeliveryRaidPriority");
        ds.field("versionNo", &self.versionNo());
        ds.field("deliveryGroupID", &self.deliveryGroupID());
        ds.finish()
    }
}
pub enum DeliveryRaidPriorityArrayOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeliveryRaidPriorityArray<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeliveryRaidPriorityArray<'a> {
    type Inner = DeliveryRaidPriorityArray<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DeliveryRaidPriorityArray<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DeliveryRaidPriorityArray { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DeliveryRaidPriorityArrayArgs<'args>,
    ) -> flatbuffers::WIPOffset<DeliveryRaidPriorityArray<'bldr>> {
        let mut builder = DeliveryRaidPriorityArrayBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(
        &self,
    ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeliveryRaidPriority<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeliveryRaidPriority>>,
                >>(DeliveryRaidPriorityArray::VT_VALUES, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for DeliveryRaidPriorityArray<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DeliveryRaidPriority>>,
            >>("values", Self::VT_VALUES, false)?
            .finish();
        Ok(())
    }
}
pub struct DeliveryRaidPriorityArrayArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DeliveryRaidPriority<'a>>>,
        >,
    >,
}
impl<'a> Default for DeliveryRaidPriorityArrayArgs<'a> {
    #[inline]
    fn default() -> Self {
        DeliveryRaidPriorityArrayArgs { values: None }
    }
}

pub struct DeliveryRaidPriorityArrayBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeliveryRaidPriorityArrayBuilder<'a, 'b> {
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DeliveryRaidPriority<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DeliveryRaidPriorityArray::VT_VALUES,
            values,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DeliveryRaidPriorityArrayBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DeliveryRaidPriorityArrayBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DeliveryRaidPriorityArray<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DeliveryRaidPriorityArray<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DeliveryRaidPriorityArray");
        ds.field("values", &self.values());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `DeliveryRaidPriorityArray`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_delivery_raid_priority_array_unchecked`.
pub fn root_as_delivery_raid_priority_array(
    buf: &[u8],
) -> Result<DeliveryRaidPriorityArray, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<DeliveryRaidPriorityArray>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `DeliveryRaidPriorityArray` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_delivery_raid_priority_array_unchecked`.
pub fn size_prefixed_root_as_delivery_raid_priority_array(
    buf: &[u8],
) -> Result<DeliveryRaidPriorityArray, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<DeliveryRaidPriorityArray>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `DeliveryRaidPriorityArray` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_delivery_raid_priority_array_unchecked`.
pub fn root_as_delivery_raid_priority_array_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<DeliveryRaidPriorityArray<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<DeliveryRaidPriorityArray<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `DeliveryRaidPriorityArray` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_delivery_raid_priority_array_unchecked`.
pub fn size_prefixed_root_as_delivery_raid_priority_array_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<DeliveryRaidPriorityArray<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<DeliveryRaidPriorityArray<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a DeliveryRaidPriorityArray and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `DeliveryRaidPriorityArray`.
pub unsafe fn root_as_delivery_raid_priority_array_unchecked(
    buf: &[u8],
) -> DeliveryRaidPriorityArray {
    flatbuffers::root_unchecked::<DeliveryRaidPriorityArray>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed DeliveryRaidPriorityArray and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `DeliveryRaidPriorityArray`.
pub unsafe fn size_prefixed_root_as_delivery_raid_priority_array_unchecked(
    buf: &[u8],
) -> DeliveryRaidPriorityArray {
    flatbuffers::size_prefixed_root_unchecked::<DeliveryRaidPriorityArray>(buf)
}
#[inline]
pub fn finish_delivery_raid_priority_array_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<DeliveryRaidPriorityArray<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_delivery_raid_priority_array_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<DeliveryRaidPriorityArray<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
